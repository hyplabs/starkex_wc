/***********************************************************************************
 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣤⠖⠉⠉⠉⣉⣙⣛⣲⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣷⣶⣿⠿⠛⠉⠉⠉⠹⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡏⠉⠂⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⡿⢣⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⣤⢄⡀⠀⠀⠀⠀⠀⣿⣤⣤⣤⣦⡄⠀⠀⢀⣿⣿⣿⠿⠿⠿⢿⣿⡇⠀⣆⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⠀⢹⡄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢸⣷⠀⠉⠂⠀⠀⠀⠀⣿⣿⠿⠿⠛⠃⠀⠀⢸⣿⣿⣏⠀⠀⠀⢸⣿⡇⠀⢻⡀⠀⠀⠀⠀⠀⣿⣿⣿⣿⠀⠀⣧⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⣿⣧⡀⠀⠀⠀⠀⠀⢱⣤⡀⠀⠀⣿⠀⠀⢸⣿⣿⣿⣷⣶⠀⣿⣿⡇⠀⢸⣧⠀⠀⠀⠀⠀⠘⠿⠿⠿⠀⠀⢹⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣶⣦⡀⠀⠀⢸⣿⣷⣀⣀⣿⣇⠀⢸⣿⣿⣿⠟⠋⠀⣿⣿⠃⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⠛⠋⠀⠀⠀⠀⣿⣿⣿⠿⠟⢿⣦⣾⣿⣿⣿⡶⠀⢠⠿⠃⠀⢀⣼⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀
⢀⣤⣤⣄⠀⠀⠀⠀⠀⠘⣿⣷⣄⣀⣀⡀⠀⢻⣤⣀⠀⠀⢸⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣴⣅⡀⠈⠙⠻⢦⣤⣀⠀⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀
⠸⣧⣀⠉⠉⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⠀⢸⣿⣿⣆⣀⣼⣿⣿⣿⣿⣟⠁⠀⠀⠀⢸⣿⣿⣿⣷⣦⣤⣤⣿⣿⣿⣿⠶⠶⠶⡾⠁⠀⠀⠀⠀⠀
⠀⠙⢿⣿⣦⣴⣶⡦⠀⠀⠀⠸⣿⣿⣿⡁⢀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⠀⢀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣴⡶⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠙⢿⣿⠋⣀⡀⣀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠈⣇⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣷⡀⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢀⠈⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠙⢿⠛⠉⠀⢀⣼⣿⣿⣿⣿⡿⠿⢿⠉⠉⢙⡿⠿⣿⣿⣿⣿⣿⠉⠀⠀⠀⠈⠿⠿⠿⠿⠿⠿⠿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⣶⣿⣿⣿⣿⣿⠿⣀⢀⣸⣷⣶⣾⣄⠀⣸⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⢀⡀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⡇⠀⢨⣿⠋⠁⠀⠈⠻⣿⡁⠀⢻⣿⣿⣯⣄⢸⣿⣶⣶⣾⣿⣿⣿⣿⣶⣶⣶⣶⡆⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢠⡏⢀⠀⣀⠔⠀⠀⠀⠈⣿⣿⣿⣿⡷⠒⢿⣇⠀⠀⠀⠀⠀⣿⡿⠒⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⣼⡁⣿⣾⡏⠀⠀⠀⠀⠀⢹⣿⣿⣿⣇⠀⣸⢿⣦⣄⣀⣠⣼⡿⣄⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢿⣿⣿⣿⡇⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⡁⠀⢹⠟⠛⢻⡅⠀⣨⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⠛⠿⣷⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣷⣿⣤⣤⣴⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣇⡀⠀⠀⠀⠈⠙⠿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠈⢿⣿⣿⣷⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠈⠻⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠈⠻⣿⣿⡄⠀⠀⠀⠀⠹⣿⣿⣇⠙⠻⠿⠿⠿⠿⠿⠛⠛⠛⠛⠛⠛⣻⣿⣿⣿⣿⣯⡀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⢿⣷⡀⠀⣄⠀⠀⠘⢿⣿⣷⣦⣤⣤⣤⣤⣤⣤⡴⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣶⣦⣄⣀⠀⠀⠀⠀⠀⠀⠈⢿⣦⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣄⠈⢷⣤⡀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠁⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣀⠀⠀⠀⠀⣿⠓⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⠛⢿⣷⣤⣿⣿⣦⣄⣀⣀⣀⣀⣀⣀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀⠀⢹⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠙⢆⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⣠⣬⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣇⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢿⣿⣿⣤⣀⠀⠀⠀⠈⠻⣿⣿⣿⣷⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⡆⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⡀⠈⠙⠿⣿⣿⣦⣄⠀⠀⠀⠙⣿⣿⣷⡀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⡀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⠻⣿⣿⣿⣿⣷⣄⠀⠀⠙⠛⠿⠷⣄⠀⠀⢸⣿⣿⣧⡀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠁⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣷⣄⠀⠀⠀⠀⠘⢷⣄⣼⣿⣿⠿⣷⣄
⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⢳⡀⠀⠀⠀⠈⢿⣿⡿⠁⠀⠀⠉
⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⡀⠀⠀⢀⣾⡟⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⣠⣿⣿⣷⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⣿⡿⠉⠙⢷⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠛⠛⠻⠿⣿⣿⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⡟⠁⠀⠀⠀⠑⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠉⠙⠻⢷⣦⣀⠀⠀⠀⢀⣠⡶⠋⠉⠻⣷⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⠈⠉⠙⠋⠉⠉⠁⠀⠀⠀⠀⠙⠛⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
**********************************************************************************/
const {IService} = require('./ServiceManager.js');
const StarkExAPI = require('@starkware-industries/starkex-js');
const starkwareCrypto = require('@starkware-industries/starkware-crypto-utils');
const crypto = require('crypto');

/**
 * StarkExWalletGateway: IService
 * An implementation of a wallet + gateway combination. Partial implementation meant to be instuctive in nature.
 */
class StarkExWalletGateway /* implements IService */ {
    /**
     * Create a new ServiceManager instance.
     * @param {Object} serviceManager our Service Manager
     * @constructor
     */    
    constructor(serviceManager,uri) {
        this.settings = {}
        this.serviceManager = serviceManager;
        this.starkExUri = uri;
        this.settings.accounts = {}
        this.settings.selectedAccount = undefined

        this.registry = {
            "TransferRequest": {
                "hashFunction": 'getTransferMsgHash',
                "args": ['amount', 'nonce', 'senderVaultId', 'token', 'receiverVaultId', 'receiverPublicKey', 'expirationTimestamp'],
            },
            "ConditionalTransferRequest": {
                "hashFunction": 'getTransferMsgHash',
                "args": ['amount', 'nonce', 'senderVaultId', 'token', 'receiverVaultId', 'receiverPublicKey', 'expirationTimestamp', 'factRegistryAddress'],
            },
            "OrderRequest": {
                "hashFunction": 'getLimitOrderMsgHash',
                "args": ['vaultIdSell', 'vaultIdBuy', 'amountSell', 'amountBuy', 'tokenSell', 'tokenBuy', 'nonce', 'expirationTimestamp'],
            },
        };

        this.sendTransactionFuncs= {
            "DepositRequest": 'deposit',
            "WithdrawalRequest": 'withdrawal',
            "SettlementRequest": 'settlement',
            "TransferRequest": 'transfer',
            "ConditionalTransferRequest": 'conditionalTransfer',
            "MultiTransactionRequest": 'multiTransaction',
        };       
    }

    set_admin_account(args,metadata)
    {
        let didSet = {providerUrl:false,
                        privateKey:false};
        if (args.providerUrl)
        {
            this.starkExAPI = new StarkExAPI({endpoint: args.providerUrl});
            didSet.providerUrl = true;
        }
        if (args.privateKey)
        {
            this.privateKey = args.privateKey;
            didSet.privateKey = true;
        }
        return didSet;
    }

    /**
     * The name of the current Service
     * @return {string}
     */        
    serviceName(){
        return "starkex"
    } 

    /**
     * Run a dynamic command, and return some result after. This method looks at the registered bound functions,
     * and routes the function calls to those modules. This is better than copying and pasting several methods
     * one by one into this interface. This method unpacks the arguments, and places them into an orderd arrangement.
     * @param {Object} args named dict of arguments intended for your command
     * @param {Object} metadata associated with your command (command, service, role)
     * @return {Object}
     */   
    /**
     * Return a dictionary that defines all methods, and roles that can access that method
     * @return {Object}
     */    
    methodRoles(){
        let roles = {
            "admin": {  
                        "get_public_key":this.get_public_key.bind(this),
                        "sign_message":this.sign_message.bind(this),
                        "select_account":this.select_account.bind(this),
                        "set_admin_account":this.set_admin_account.bind(this),
                        "generate_stark_account_from_public_key":this.generate_stark_account_from_public_key.bind(this),
                        "get_key_material":this.get_key_material.bind(this),
                        "generate_request_hash":this.generate_request_hash.bind(this),
                        "getTransaction":this.getTransaction.bind(this),
                        "getFirstUnusedTxId":this.getFirstUnusedTxId.bind(this),
                        "sendTransaction":this.sendTransaction.bind(this),
                        },
            "user" : {
                "getFirstUnusedTxId":this.getFirstUnusedTxId.bind(this),
                "getTransaction":this.getTransaction.bind(this),
            }
        }; 
        return roles;
    }  
    async getTransaction(args,metadata) {
        return await this.starkExAPI.gateway.getTransaction(args.txId);
    }

    async getFirstUnusedTxId(args,metadata) {
        let val;
        try 
        {
            console.log("starkExAPI!!!!!!!!!!!!!!!!!!!");
            console.log(JSON.stringify(this.starkExAPI.gateway));
            console.log(JSON.stringify(this.starkExAPI.gateway.getFirstUnusedTxId));
            let starkExAPI = new StarkExAPI({endpoint: "https://gw.playground-v2.starkex.co"});            
            let val = await starkExAPI.gateway.getFirstUnusedTxId();
            console.log(val);
            return val;
        } 
        catch (e) 
        {
            console.log("error val")
            console.log(val)
            console.log(e)
            return val
            //return "1889";
        //    return {"error": `(b) ${e}, Could not access transaction id from this.starkExAPI.gateway.getFirstUnusedTxId`}; 
        }        
        
    }    


    /**
     * list_accounts
     * @return {Object}
     */        
    list_accounts(args,metadata) {
        return Object.keys(this.settings.accounts);    
    }      
    
    /**
     * select_account
     * @return {Object}
     */        
    select_account(args,metadata) {
        if (Object.keys(this.settings.accounts).includes(args.starkKey))
        {
            this.settings.selectedAccount = this.settings.accounts[args.starkKey];
            return args.starkKey;
        }//
        return {"error":"could not find account associated with the starkKey supplied"}        
    }

    async generate_stark_account_from_public_key(args,metadata){
        if (!args.publicKey)
        {
            return {"error":"you do not have a publicKey argument"}
        }
        // Request of the linked service that we want private account details
        // Since we are in an admin context, we can just run this.
        let ethAccount = await this.serviceManager.run("eth", "admin",  "expose_account", 
        {
          "publicKey": args.publicKey,
        });       
        if (ethAccount.error)
            return {"error":"got an error from the eth service looking up the publicKey :"+val.error}
        if (!ethAccount.privateKey)
            return {"error":"Internal error. Somehow do not have a private Key"}

        if (!ethAccount.publicKey)
            return {"error":"Internal error. Somehow do not have a public Key"}
        let starkAcc = this.generate_stark_account_from_private_key({"privateKey":ethAccount.privateKey},{})
        this.settings.accounts[starkAcc.starkKey] = starkAcc;
        return {"starkKey":starkAcc.starkKey}      
    }

    generate_stark_account_from_private_key(args,metadata) {
        if (!args.privateKey)
        {
            return {"error":"you do not have a publicKey argument"}
        }
        let dat = {privateKey:args.privateKey}        
        const keyPair = starkwareCrypto.ec.keyFromPrivate(args.privateKey, "hex");
        const acc = starkwareCrypto.ec.keyFromPublic(keyPair.getPublic(true, "hex"), "hex");
        dat['account'] =  acc.pub.getX().toString("hex");
        dat['starkKey'] =  keyPair.getPublic(true, "hex");
        this.settings.accounts[dat.starkKey] = dat;
        return dat;
    }

    /**
     * get_public_key
     * @return {Object}
     */        
    async get_public_key(args,metadata) {
        return {
            "res":`Returns: an array of public keys available to sign from the wallet.`,
        }
    }

    /**
     * generate_request_hash
     * @return {Object}
     */        
    async generate_request_hash(request,metadata) {
        let msgHash;
        const requestType = request.type;
        if (!this.registry[requestType]) 
            return {"error":`Unsupported request type: ${requestType}`}

        let requestTemplate = this.registry[requestType]; 
        if (request.feeInfoUser) {
            requestTemplate.args.push('feeInfoUser.token', 'feeInfoUser.sourceVaultId', 'feeInfoUser.feeLimit');
        } else if(request.feeInfo) {
            requestTemplate.args.push('feeInfo.token', 'feeInfo.sourceVaultId', 'feeInfo.feeLimit');
        }
        if (!requestTemplate.hashFunction) 
            return {"error":`Unsupported hashFunction type: ${requestType}.${requestTemplate.hashFunction}`}
        
        let anError = null;
        requestTemplate.args.forEach((param) =>{
            if(!Object.keys(request).includes(param))  
                anError = `Missing param for : ${requestType}.${requestTemplate.hashFunction}  ${param}`;
        });
        if (anError) return {"error":anError};
        let tonyStarkFunc = starkwareCrypto[requestTemplate.hashFunction];         
        msgHash = tonyStarkFunc(...requestTemplate.args.map(arg => request[arg]));
        return msgHash.toString(16);
        //let msgHashRecover = parseInt(hexString, 16);
    }

    /**
     * sign_message
     * @return {Object}
     */        
    async sign_message(args,metadata) {
        // /return {'error':"not finished"}
        let msgHash;
        if (!(args.hash))
            msgHash = this.generate_request_hash(args);
        else
            msgHash = args.hash;
        const keyPair = starkwareCrypto.ec.keyFromPrivate("0x8da4ef21b864d2cc526dbdb2a120bd2874c36c9d0a1fb7f8c63d7f7a8b41de8f", 'hex');
        let msgHashRecover = parseInt(msgHash, 16);

        const msgSignature = starkwareCrypto.sign(keyPair, msgHashRecover);
        return {r: '0x' + msgSignature.r.toString(16), s: '0x' + msgSignature.s.toString(16)};
    }

    async sendTransaction(args,metadata) {
        let txId;
        let response;
        try 
        {
            txId = await this.getFirstUnusedTxId({},{});
        } 
        catch (e) 
        {
            return {"error": `${e}, Could not access transaction id from this.starkExAPI.gateway.getFirstUnusedTxId`}; 
        }
        
        if (!args.type || !Object.keys(this.sendTransactionFuncs).includes(args.type))
            return {"error":`Could not find type ${args.type} in sendTransactionFuncs.`}

        try 
        {
            Object.assign(args, {txId});
            const methodName = this.sendTransactionFuncs[args.type];
            //delete args[args.type]; 
            response = await this.starkExAPI.gateway[methodName](args);
        } catch (e) {
            return {"error":`Could not send transaction ${JSON.stringify(args)} ${JSON.stringify(e)} `}
        }
        return response;
    }

    /**
     * get_key_material
     * @return {Object}
     */        
    async get_key_material(args, metadata) {
        let seed = args.seed || '';
        let number = args.number || 0;
        let seedNumber = seed + number.toString();
        let keyMaterial = crypto.createHmac('sha256', seedNumber)
            .update(Math.random().toString())
            .digest('hex');
        let deterministicRandomNumber = parseInt(keyMaterial.slice(0,8),16);
        return {
            "result": deterministicRandomNumber.toString(16)
         }
    }
    /*
    async get_key_material(args, metadata) {
        let seed = args.seed || '';
        let number = args.number || 0;
        let seedNumber = seed + number.toString();
        let keyMaterial = crypto.createHmac('sha256', seedNumber)
            .update(Math.random().toString())
            .digest('hex');
        let deterministicRandomNumber = parseInt(keyMaterial.slice(0,8),16);
        return {
            "result": deterministicRandomNumber.toString(16)
         }
    }*/
} 
module.exports = StarkExWalletGateway;