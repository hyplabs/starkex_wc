/***********************************************************************************
-- Welcome to the StarkEx Integration.
Hype would like to officially request that you place an ASCII image 
of iron man in the beginning of all your files
 
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣤⠖⠉⠉⠉⣉⣙⣛⣲⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⢀⣼⣿⣿⣿⣿⣷⣶⣿⠿⠛⠉⠉⠉⠹⣿⣿⣷⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡏⠉⠂⠀⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⡿⢣⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣦⡀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢀⣤⢄⡀⠀⠀⠀⠀⠀⣿⣤⣤⣤⣦⡄⠀⠀⢀⣿⣿⣿⠿⠿⠿⢿⣿⡇⠀⣆⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⠀⢹⡄⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢸⣷⠀⠉⠂⠀⠀⠀⠀⣿⣿⠿⠿⠛⠃⠀⠀⢸⣿⣿⣏⠀⠀⠀⢸⣿⡇⠀⢻⡀⠀⠀⠀⠀⠀⣿⣿⣿⣿⠀⠀⣧⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠘⣿⣧⡀⠀⠀⠀⠀⠀⢱⣤⡀⠀⠀⣿⠀⠀⢸⣿⣿⣿⣷⣶⠀⣿⣿⡇⠀⢸⣧⠀⠀⠀⠀⠀⠘⠿⠿⠿⠀⠀⢹⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣶⣦⡀⠀⠀⢸⣿⣷⣀⣀⣿⣇⠀⢸⣿⣿⣿⠟⠋⠀⣿⣿⠃⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⠛⠋⠀⠀⠀⠀⣿⣿⣿⠿⠟⢿⣦⣾⣿⣿⣿⡶⠀⢠⠿⠃⠀⢀⣼⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀
⢀⣤⣤⣄⠀⠀⠀⠀⠀⠘⣿⣷⣄⣀⣀⡀⠀⢻⣤⣀⠀⠀⢸⣿⣿⣿⣿⣿⡟⠀⠀⠀⠀⣴⣅⡀⠈⠙⠻⢦⣤⣀⠀⠀⠀⠀⠀⢀⡇⠀⠀⠀⠀⠀
⠸⣧⣀⠉⠉⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⠀⢸⣿⣿⣆⣀⣼⣿⣿⣿⣿⣟⠁⠀⠀⠀⢸⣿⣿⣿⣷⣦⣤⣤⣿⣿⣿⣿⠶⠶⠶⡾⠁⠀⠀⠀⠀⠀
⠀⠙⢿⣿⣦⣴⣶⡦⠀⠀⠀⠸⣿⣿⣿⡁⢀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⠀⢀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣴⡶⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠙⢿⣿⠋⣀⡀⣀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⠀⠈⣇⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠙⢿⣿⣿⣿⣷⡀⠘⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⢀⠈⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠙⢿⠛⠉⠀⢀⣼⣿⣿⣿⣿⡿⠿⢿⠉⠉⢙⡿⠿⣿⣿⣿⣿⣿⠉⠀⠀⠀⠈⠿⠿⠿⠿⠿⠿⠿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⣶⣿⣿⣿⣿⣿⠿⣀⢀⣸⣷⣶⣾⣄⠀⣸⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⢀⡀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣿⣿⡇⠀⢨⣿⠋⠁⠀⠈⠻⣿⡁⠀⢻⣿⣿⣯⣄⢸⣿⣶⣶⣾⣿⣿⣿⣿⣶⣶⣶⣶⡆⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢠⡏⢀⠀⣀⠔⠀⠀⠀⠈⣿⣿⣿⣿⡷⠒⢿⣇⠀⠀⠀⠀⠀⣿⡿⠒⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⣼⡁⣿⣾⡏⠀⠀⠀⠀⠀⢹⣿⣿⣿⣇⠀⣸⢿⣦⣄⣀⣠⣼⡿⣄⢀⣼⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠛⠋⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢿⣿⣿⣿⡇⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⡁⠀⢹⠟⠛⢻⡅⠀⣨⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⠛⠿⣷⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⢸⣿⣿⣿⡇⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣷⣿⣤⣤⣴⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⣇⡀⠀⠀⠀⠈⠙⠿⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠈⢿⣿⣿⣷⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡄⠀⠀⠀⠀⠈⠻⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠈⠻⣿⣿⡄⠀⠀⠀⠀⠹⣿⣿⣇⠙⠻⠿⠿⠿⠿⠿⠛⠛⠛⠛⠛⠛⣻⣿⣿⣿⣿⣯⡀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠈⢿⣷⡀⠀⣄⠀⠀⠘⢿⣿⣷⣦⣤⣤⣤⣤⣤⣤⡴⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣶⣦⣄⣀⠀⠀⠀⠀⠀⠀⠈⢿⣦⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣄⠈⢷⣤⡀⠀⠈⠉⠉⠉⠉⠉⠉⠉⠁⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣤⣀⠀⠀⠀⠀⣿⠓⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⠛⢿⣷⣤⣿⣿⣦⣄⣀⣀⣀⣀⣀⣀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⡀⠀⢹⡄⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⠙⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⠀⠙⢆⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⠀⠀⣠⣬⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠛⠛⠿⣿⣿⣿⣿⣷⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣇⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢿⣿⣿⣤⣀⠀⠀⠀⠈⠻⣿⣿⣿⣷⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⡆⠈⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⡀⠈⠙⠿⣿⣿⣦⣄⠀⠀⠀⠙⣿⣿⣷⡀⠀⠀
⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⡀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⠻⣿⣿⣿⣿⣷⣄⠀⠀⠙⠛⠿⠷⣄⠀⠀⢸⣿⣿⣧⡀⠀
⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⡇⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡟⠁⠀⠀⠀⠀⠀⠙⠻⣿⣿⣿⣷⣄⠀⠀⠀⠀⠘⢷⣄⣼⣿⣿⠿⣷⣄
⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠉⠉⢳⡀⠀⠀⠀⠈⢿⣿⡿⠁⠀⠀⠉
⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⣀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢳⡀⠀⠀⢀⣾⡟⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⡀⣠⣿⣿⣷⡀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣹⣿⡿⠉⠙⢷⡀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠋⠛⠛⠻⠿⣿⣿⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⡟⠁⠀⠀⠀⠑⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣄⠀⠀⠉⠙⠻⢷⣦⣀⠀⠀⠀⢀⣠⡶⠋⠉⠻⣷⡄⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠉⠉⠉⠉⠁⠀⠀⠀⠀⠀⠈⠉⠙⠋⠉⠉⠁⠀⠀⠀⠀⠙⠛⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
**********************************************************************************/



const {IService} = require('./ServiceManager.js');
//const stark_wallet = require('../stark_wallet');
//const Storage = require('./storage');
//const {createAccount} = require('./crypto');
//const StarkExPerpetualAPI = require('./stark-ex-perpetual');
const StarkExAPI = require('@starkware-industries/starkex-js');
const starkwareCrypto = require('@starkware-industries/starkware-crypto-utils');
const crypto = require('crypto');

/*
const registry = {
    TRANSFER_REQUEST: {
        hashFunction: 'getTransferMsgHash',
        args: ['amount', 'nonce', 'senderVaultId', 'token', 'receiverVaultId', 'receiverPublicKey', 'expirationTimestamp'],
    },
    CONDITIONAL_TRANSFER_REQUEST: {
        hashFunction: 'getTransferMsgHash',
        args: ['amount', 'nonce', 'senderVaultId', 'token', 'receiverVaultId', 'receiverPublicKey', 'expirationTimestamp', 'factRegistryAddress'],
    },
    ORDER_REQUEST: {
        hashFunction: 'getLimitOrderMsgHash',
        args: ['vaultIdSell', 'vaultIdBuy', 'amountSell', 'amountBuy', 'tokenSell', 'tokenBuy', 'nonce', 'expirationTimestamp'],
    },
};
const transactionRegistry = {
    [GatewayRequestType.DEPOSIT_REQUEST]: 'deposit',
    [GatewayRequestType.WITHDRAWAL_REQUEST]: 'withdrawal',
    [GatewayRequestType.SETTLEMENT_REQUEST]: 'settlement',
    [GatewayRequestType.TRANSFER_REQUEST]: 'transfer',
    [GatewayRequestType.CONDITIONAL_TRANSFER_REQUEST]: 'conditionalTransfer',
    [GatewayRequestType.MULTI_TRANSACTION_REQUEST]: 'multiTransaction',
};

class StarkExWallet {
    constructor(){
        this.starkExSpotAPI = new StarkExAPI({endpoint: config.starkExApiSpotEndpoint});
        //this.starkExPerpetualAPI = new StarkExPerpetualAPI({endpoint: config.starkExApiPerpetualEndpoint});
    }
    setConfig(config) {
        this.starkExSpotAPI = new StarkExAPI({endpoint: config.starkExApiSpotEndpoint});
        //this.starkExPerpetualAPI = new StarkExPerpetualAPI({endpoint: config.starkExApiPerpetualEndpoint});
    }

    async createAccount() {
        const account = await createAccount();
        return account;
    }

    async getFirstUnusedTxId() {
        return await this.starkExSpotAPI.gateway.getFirstUnusedTxId();
    }

   signMessage(request) {
        let msgHash;
        const requestType = request.type;
        if (!registry[requestType]) {
            throw new Error(`Unsupported request type: ${requestType}`);
        }
        if (request.feeInfoUser) {
            registry[requestType].args.push('feeInfoUser.token', 'feeInfoUser.sourceVaultId', 'feeInfoUser.feeLimit');
        } else if(request.feeInfo) {
            registry[requestType].args.push('feeInfo.token', 'feeInfo.sourceVaultId', 'feeInfo.feeLimit');
        }

        msgHash = starkwareCrypto[registry[requestType].hashFunction](...registry[requestType].args.map(arg => request[arg]));
        return msgHash;
        const keyPair = starkwareCrypto.ec.keyFromPrivate(this.storage.getPrivateKey(), 'hex');
        const msgSignature = starkwareCrypto.sign(keyPair, msgHash);
        return {r: '0x' + msgSignature.r.toString(16), s: '0x' + msgSignature.s.toString(16)};
    }

    async function sendTransaction(request) {
        let txId;
        let response;
        try {
            txId = await this.starkExSpotAPI.gateway.getFirstUnusedTxId();
        } catch (e) {
            console.warn(e);
        }
        try {
            Object.assign(request, {txId});
            const methodName = transactionRegistry[request.type];
            response = await this.starkExSpotAPI.gateway[methodName](request);
        } catch (e) {
            console.error(e.message);
        }
        return response;
    }

*/


/**
 * StarkExWalletGateway: IService
 * An implementation of a wallet + gateway combination. Partial implementation meant to be instuctive in nature.
 */
class StarkExWalletGateway /* implements IService */ {
    /**
     * Create a new ServiceManager instance.
     * @param {Object} serviceManager our Service Manager
     * @constructor
     */    
    constructor(serviceManager) {
        this.setting = {}
        this.serviceManager = serviceManager;
        this.registry = {
            "TRANSFER_REQUEST": {
                "hashFunction": 'getTransferMsgHash',
                "args": ['amount', 'nonce', 'senderVaultId', 'token', 'receiverVaultId', 'receiverPublicKey', 'expirationTimestamp'],
            },
            "CONDITIONAL_TRANSFER_REQUEST": {
                "hashFunction": 'getTransferMsgHash',
                "args": ['amount', 'nonce', 'senderVaultId', 'token', 'receiverVaultId', 'receiverPublicKey', 'expirationTimestamp', 'factRegistryAddress'],
            },
            "ORDER_REQUEST": {
                "hashFunction": 'getLimitOrderMsgHash',
                "args": ['vaultIdSell', 'vaultIdBuy', 'amountSell', 'amountBuy', 'tokenSell', 'tokenBuy', 'nonce', 'expirationTimestamp'],
            },
        };
        
    }
    
    /**
     * The name of the current Service
     * @return {string}
     */        
    serviceName(){
        return "starkex"
    } 

    /**
     * Run a command, and return some result after.
     * @param {Object} args Arguments intended for your command
     * @param {Object} metadata associated with your command (command, service, role)
     * @return {Object}
     */        
    run(args,metadata){
        return {"error":"Likely not using service router in this simple example Wallet Service"}
        let event = {...metadata};
        //this.serviceManager.emit(this.serviceName(), metadata); // emit an event
        return this[metadata['command']](args);
    }

    /**
     * Return a dictionary that defines all methods, and roles that can access that method
     * @return {Object}
     */    
    methodRoles(){
        return {
            "admin": {  
                        "get_public_key":this.get_public_key.bind(this),
                        "sign_message":this.sign_message.bind(this),
                        "get_key_material":this.get_key_material.bind(this),
                        "generate_request_hash":this.generate_request_hash.bind(this),
                        },
            "user" : {}
        };
    }  
    
    /**
     * get_public_key
     * @return {Object}
     */        
    async get_public_key(args,metadata) {
        return {
            "res":`Returns: an array of public keys available to sign from the wallet.`,
        }
    }

    /**
     * generate_request_hash
     * @return {Object}
     */        
    async generate_request_hash(request,metadata) {
        let msgHash;
        const requestType = request.type;
        if (!this.registry[requestType]) 
            return {"error":`Unsupported request type: ${requestType}`}

        let requestTemplate = this.registry[requestType]; 
        if (request.feeInfoUser) {
            requestTemplate.args.push('feeInfoUser.token', 'feeInfoUser.sourceVaultId', 'feeInfoUser.feeLimit');
        } else if(request.feeInfo) {
            requestTemplate.args.push('feeInfo.token', 'feeInfo.sourceVaultId', 'feeInfo.feeLimit');
        }
        if (!requestTemplate.hashFunction) 
            return {"error":`Unsupported hashFunction type: ${requestType}.${requestTemplate.hashFunction}`}
        
        let anError = null;
        requestTemplate.args.forEach((param) =>{
            if(!Object.keys(request).includes(param))  
                anError = `Missing param for : ${requestType}.${requestTemplate.hashFunction}  ${param}`;
        });
        if (anError) return {"error":anError};
        let tonyStarkFunc = starkwareCrypto[requestTemplate.hashFunction];         
        msgHash = tonyStarkFunc(...requestTemplate.args.map(arg => request[arg]));
        return msgHash.toString(16);
        //let msgHashRecover = parseInt(hexString, 16);
    }
    
    /**
     * sign_message
     * @return {Object}
     */        
    async sign_message(args,metadata) {
        // /return {'error':"not finished"}
        let msgHash;
        if (!(args.hash))
            msgHash = this.generate_request_hash(args);
        else
            msgHash = args.hash;
        const keyPair = starkwareCrypto.ec.keyFromPrivate("0x8da4ef21b864d2cc526dbdb2a120bd2874c36c9d0a1fb7f8c63d7f7a8b41de8f", 'hex');
        let msgHashRecover = parseInt(msgHash, 16);

        const msgSignature = starkwareCrypto.sign(keyPair, msgHashRecover);
        return {r: '0x' + msgSignature.r.toString(16), s: '0x' + msgSignature.s.toString(16)};
    }

    /**
     * get_key_material
     * @return {Object}
     */        
    async get_key_material(args, metadata) {
        let seed = args.seed || '';
        let number = args.number || 0;
        let seedNumber = seed + number.toString();
        let keyMaterial = crypto.createHmac('sha256', seedNumber)
            .update(Math.random().toString())
            .digest('hex');
        let deterministicRandomNumber = parseInt(keyMaterial.slice(0,8),16);
        return {
            "result": deterministicRandomNumber.toString(16)
         }
    }

    ///
    ///
    /// TODO / Dev note
    // Just leaving the payloads here for now, as they might be useful as a reference list / schema later
    /*
    async starkex_spot_v1_transfer_payload(args,metadata) {
        //https://docs.google.com/document/d/1kZMM7hIeKQtBfqtmuFUmLiW_oBxO0rsyEZJYNtFLQL4/edit        
        return {
            "res":`    {
                "type": 1,						
                "sender_vault_id": integer,			
                "receiver_vault_id": integer,			
                "amount": integer,	
                “nonce”: integer,	
                "expiration_timestamp": integer,		
                "token": hex string,				
                "receiver_public_key": hex string,	
                }`,
        }
    }
    
    async starkex_spot_v1_conditional_transfer_payload(args,metadata) {
        return {
            "res":`{
                "type": 2,						
                "sender_vault_id": integer,			
                "receiver_vault_id": integer,			
                "amount": integer,	
                “nonce”: integer,	
                "expiration_timestamp": integer,		
                "token": “hex string”,		
                "receiver_public_key": hex string,
                     “condition”: hex string,
                }
                `,
        }
    }


    async starkex_spot_limit_order_with_fees_payload(args,metadata) {
        return {
            "res":`{
                "type": 3,			
                "vault_sell": integer,
                "vault_buy": integer,	
                "amount_sell": integer,
                “amount_buy”: integer,
                “nonce”: integer,
                "expiration_timestamp": integer,
           "fee_limit": integer,
           "fee_vault_id": integer,
                "fee_token": hex string,
                "token_sell": hex string,
           "token_buy": hex string,
           }
           `,
        }
    }
    async starkex_spot_transfer_with_fees_payload (args,metadata) {
        return {
            "res":`{
                "type": 4,	
                "sender_vault_id": integer,			
           "receiver_vault_id": integer,			
           "amount": integer,	
           “nonce”: integer,	
           "expiration_timestamp": integer,
           "fee_limit": integer,
           "fee_vault_id": integer,
           "fee_token": hex string,	
           "token": hex string,				
           "receiver_public_key": hex string,
           }
           `,
        }
    }
    async starkex_spot_conditional_transfer_with_fees_payload(args,metadata) {
        return {
            "res":`Returns: random and deterministic 32 bytes key material..`,
        }
    }

    
    async starkex_spot_multi_asset_order_offchain_payload(args,metadata) {
        return {
            "res":`Returns: random and deterministic 32 bytes key material..`,
        }
    }

    async starkex_perpetual_limit_order_payload(args,metadata) {
        return {
            "res":`Returns: random and deterministic 32 bytes key material..`,
        }
    }

    async starkex_perpetual_transfer_payload(args,metadata) {
        return {
            "res":`Returns: random and deterministic 32 bytes key material..`,
        }
    }
    
    async starkex_perpetual_conditional_transfer_payload(args,metadata) {
        return {
            "res":`Returns: random and deterministic 32 bytes key material..`,
        }
    }
    */
    
 
    

} 
module.exports = StarkExWalletGateway;